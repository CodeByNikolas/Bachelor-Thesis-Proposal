@inproceedings{bargmann:2019:SurveySecureContainer,
  title = {A {{Survey On Secure Container Isolation Approaches}} for {{Multi-Tenant Container Workloads}} and {{Serverless Computing}}},
  author = {Bargmann, Christian and Tropmann-Frick, Marina},
  date = {2019},
  langid = {english},
  file = {/Users/nik/Zotero/storage/RJC8PL7C/Bargmann and Tropmann-Frick - A Survey On Secure Container Isolation Approaches for Multi-Tenant Container Workloads and Serverles.pdf}
}

@inproceedings{barros:2022:EditingSupportSoftware,
  title = {Editing Support for Software Languages: Implementation Practices in Language Server Protocols},
  shorttitle = {Editing Support for Software Languages},
  booktitle = {Proceedings of the 25th {{International Conference}} on {{Model Driven Engineering Languages}} and {{Systems}}},
  author = {Barros, Djonathan and Peldszus, Sven and Assunção, Wesley K. G. and Berger, Thorsten},
  date = {2022-10-24},
  series = {{{MODELS}} '22},
  pages = {232--243},
  publisher = {Association for Computing Machinery},
  doi = {10.1145/3550355.3552452},
  url = {https://dl.acm.org/doi/10.1145/3550355.3552452},
  urldate = {2025-09-02},
  abstract = {Effectively using software languages, be it programming or domain-specific languages, requires effective editing support. Modern IDEs, modeling tools, and code editors typically provide sophisticated support to create, comprehend, or modify instances---programs or models---of particular languages. Unfortunately, building such editing support is challenging. While the engineering of languages is well understood and supported by modern model-driven techniques, there is a lack of engineering principles and best practices for realizing their editing support. Especially domain-specific languages---often created by smaller organizations or individual developers, sometimes even for single projects---would benefit from better methods and tools to create proper editing support.We study practices for implementing editing support in 30 so-called language servers---implementations of the language server protocol (LSP). The latter is a recent de facto standard to realize editing support for languages, separated from the editing tools (e.g., IDEs or modeling tools), enhancing the reusability and quality of the editing support. Witnessing the LSP's popularity---a whopping 121 language servers are in existence today---we take this opportunity to analyze the implementations of 30 language servers, some of which support multiple languages. We identify concerns that developers need to take into account when developing editing support, and we synthesize implementation practices to address them, based on a systematic analysis of the servers' source code. We hope that our results shed light on an important technology for software language engineering, that facilitates language-oriented programming and systems development, including model-driven engineering.},
  isbn = {978-1-4503-9466-6},
  file = {/Users/nik/Zotero/storage/P9DNLSLR/Barros et al. - 2022 - Editing support for software languages implementation practices in language server protocols.pdf}
}

@inproceedings{laigner:2025:TransactionalCloudApplications,
  title = {Transactional {{Cloud Applications}}: {{Status Quo}}, {{Challenges}}, and {{Opportunities}}},
  shorttitle = {Transactional {{Cloud Applications}}},
  booktitle = {Companion of the 2025 {{International Conference}} on {{Management}} of {{Data}}},
  author = {Laigner, Rodrigo and Christodoulou, George and Psarakis, Kyriakos and Katsifodimos, Asterios and Zhou, Yongluan},
  date = {2025-06-22},
  eprint = {2504.17106},
  eprinttype = {arXiv},
  eprintclass = {cs},
  pages = {829--836},
  doi = {10.1145/3722212.3725635},
  url = {http://arxiv.org/abs/2504.17106},
  urldate = {2025-09-02},
  abstract = {Transactional cloud applications such as payment, booking, reservation systems, and complex business workflows are currently being rewritten for deployment in the cloud. This migration to the cloud is happening mainly for reasons of cost and scalability. Over the years, application developers have used different migration approaches, such as microservice frameworks, actors, and stateful dataflow systems. The migration to the cloud has brought back data management challenges traditionally handled by database management systems. Those challenges include ensuring state consistency, maintaining durability, and managing the application lifecycle. At the same time, the shift to a distributed computing infrastructure introduced new issues, such as message delivery, task scheduling, containerization, and (auto)scaling. Although the data management community has made progress in developing analytical and transactional database systems, transactional cloud applications have received little attention in database research. This tutorial aims to highlight recent trends in the area and discusses open research challenges for the data management community.},
  keywords = {Computer Science - Databases,Computer Science - Software Engineering},
  file = {/Users/nik/Zotero/storage/AZT3S4NN/Laigner et al. - 2025 - Transactional Cloud Applications Status Quo, Challenges, and Opportunities.pdf;/Users/nik/Zotero/storage/U5YEWYSE/2504.html}
}

@inproceedings{leitner:2012:ApplicationlevelPerformanceMonitoring,
  title = {Application-Level Performance Monitoring of Cloud Services Based on the Complex Event Processing Paradigm},
  booktitle = {2012 {{Fifth IEEE International Conference}} on {{Service-Oriented Computing}} and {{Applications}} ({{SOCA}})},
  author = {Leitner, Philipp and Inzinger, Christian and Hummer, Waldemar and Satzger, Benjamin and Dustdar, Schahram},
  date = {2012-12},
  pages = {1--8},
  publisher = {IEEE},
  doi = {10.1109/SOCA.2012.6449437},
  url = {http://ieeexplore.ieee.org/document/6449437/},
  urldate = {2025-09-02},
  abstract = {Monitoring of applications deployed to Infrastructure as-a-Service clouds is still an open problem. In this paper, we discuss an approach based on the complex event processing paradigm, which allows application developers to specify and monitor high-level application performance metrics. We use the case of a Web 2.0 sentiment anal ysis application to illustrate the limitations we currently experience with regard to cloud monitoring, and show how our approach allows for more expressive definitions of monitored metrics. Furthermore, we indicate how the higher-level metrics produced by our approach can be used to increase application elasticity in an existing cloud middleware.},
  eventtitle = {2012 5th {{IEEE International Conference}} on {{Service-Oriented Computing}} and {{Applications}} ({{SOCA}})},
  isbn = {978-1-4673-4775-4 978-1-4673-4773-0 978-1-4673-4774-7},
  langid = {english},
  file = {/Users/nik/Zotero/storage/VLG47XBX/Leitner et al. - 2012 - Application-level performance monitoring of cloud services based on the complex event processing par.pdf}
}

@article{rahaman:2023:AccessControlDesign,
  title = {Access {{Control Design Practice}} and {{Solutions}} in {{Cloud-Native Architecture}}: {{A Systematic Mapping Study}}},
  shorttitle = {Access {{Control Design Practice}} and {{Solutions}} in {{Cloud-Native Architecture}}},
  author = {Rahaman, Md Shahidur and Tisha, Sadia Nasrin and Song, Eunjee and Cerny, Tomas},
  date = {2023-01},
  journaltitle = {Sensors},
  volume = {23},
  number = {7},
  pages = {3413},
  publisher = {Multidisciplinary Digital Publishing Institute},
  issn = {1424-8220},
  doi = {10.3390/s23073413},
  url = {https://www.mdpi.com/1424-8220/23/7/3413},
  urldate = {2025-09-02},
  abstract = {Protecting the resources of a cloud-native application is essential to meet an organization’s security goals. Cloud-native applications manage thousands of user requests, and an organization must employ a proper access control mechanism. However, unfortunately, developers sometimes grumble when designing and enforcing access decisions for a gigantic scalable application. It is sometimes complicated to choose the potential access control model for the system. Cloud-native software architecture has become an integral part of the industry to manage and maintain customer needs. A microservice is a combination of small independent services that might have hundreds of parts, where the developers must protect the individual services. An efficient access control model can defend the respective services and consistency. This study intends to comprehensively analyze the current access control mechanism and techniques utilized in cloud-native architecture. For this, we present a systematic mapping study that extracts current approaches, categorizes access control patterns, and provides developers guidance to meet security principles. In addition, we have gathered 234 essential articles, of which 29 have been chosen as primary studies. Our comprehensive analysis will guide practitioners to identify proper access control mechanisms applicable to ensuring security goals in cloud-native architectures.},
  langid = {english},
  keywords = {access control,authentication,authorization,cloud-native,microservice,security},
  file = {/Users/nik/Zotero/storage/9F9J3JXE/Rahaman et al. - 2023 - Access Control Design Practice and Solutions in Cloud-Native Architecture A Systematic Mapping Stud.pdf}
}

@inproceedings{rai:2024:IntegratedDevelopmentEnvironment,
  title = {Integrated {{Development Environment}} Using {{Cloud Computing}} ({{IDECC}})},
  author = {Rai, Sanskar and Kesarwani, Rishabh and family=Sharma, given=Nishant [Guided, prefix=by, useprefix=false},
  date = {2024},
  publisher = {Jaypee University of Information Technology, Solan, H.P.},
  url = {http://www.ir.juit.ac.in:8080/jspui/jspui/handle/123456789/11415},
  urldate = {2025-09-02},
  abstract = {SP2024101 [Enrollment No. 201256, 201532]},
  langid = {american},
  annotation = {Accepted: 2024-08-06T05:46:16Z}
}

@article{rask:2021:SpecificationLanguageServer,
  title = {The {{Specification Language Server Protocol}}: {{A Proposal}} for {{Standardised LSP Extensions}}},
  shorttitle = {The {{Specification Language Server Protocol}}},
  author = {Rask, Jonas Kjær and Madsen, Frederik Palludan and Battle, Nick and Macedo, Hugo Daniel and Larsen, Peter Gorm},
  date = {2021-08-06},
  journaltitle = {Electronic Proceedings in Theoretical Computer Science},
  shortjournal = {Electron. Proc. Theor. Comput. Sci.},
  volume = {338},
  eprint = {2108.02961},
  eprinttype = {arXiv},
  eprintclass = {cs},
  pages = {3--18},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.338.3},
  url = {http://arxiv.org/abs/2108.02961},
  urldate = {2025-09-02},
  abstract = {The Language Server Protocol (LSP) changed the field of Integrated Development Environments(IDEs), as it decouples core (programming) language features functionality from editor smarts, thus lowering the effort required to extend an IDE to support a language. The concept is a success and has been adopted by several programming languages and beyond. This is shown by the emergence of several LSP implementations for the many programming and specification languages (languages with a focus on modelling, reasoning, or proofs). However, for such languages LSP has been ad-hocly extended with the additional functionalities that are typically not found for programming languages and thus not supported in LSP. This foils the original LSP decoupling goal, because the move towards a new IDE requires yet another re-implementation of the ad-hoc LSP extension. In this paper we contribute with a conservative extension of LSP providing a first proposal towards a standard protocol decoupling the support of specification languages from the IDE. We hope our research attracts the larger community and motivates the need of a joint task force leading to a standardised LSP extension serving the particular needs of specification languages.},
  keywords = {Computer Science - Software Engineering},
  file = {/Users/nik/Zotero/storage/YQ8SWAFA/Rask et al. - 2021 - The Specification Language Server Protocol A Proposal for Standardised LSP Extensions.pdf}
}

@inproceedings{saini:2019:WebCollaborativeModelling,
  title = {Towards {{Web Collaborative Modelling}} for the {{User Requirements Notation Using Eclipse Che}} and {{Theia IDE}}},
  booktitle = {2019 {{IEEE}}/{{ACM}} 11th {{International Workshop}} on {{Modelling}} in {{Software Engineering}} ({{MiSE}})},
  author = {Saini, Rijul and Bali, Shivani and Mussbacher, Gunter},
  date = {2019-05},
  pages = {15--18},
  issn = {2575-4475},
  doi = {10.1109/MiSE.2019.00010},
  url = {https://ieeexplore.ieee.org/document/8877072},
  urldate = {2025-09-02},
  abstract = {Collaborative modelling has become a necessity when developing a complex system or in a team of modellers with a diverse set of expertise. Textual notations have a long history in software engineering because of their fast editing style, simple usage, and scalability. Therefore, we propose a novel collaborative modelling framework for the graphical User Requirements Notation (URN) which we call tColab. It uses the text-based TGRL (Textual Goal-oriented Requirement Language) to build URN goal models and then automatically generates corresponding graphical models. This framework is based on the architecture of Eclipse Che and Theia. On one side, Theia provides support for LSP (Language Server Protocol) so that textual models can be built and their corresponding graphical models can be generated in a browser IDE (Integrated Development Environment). On the other hand, Eclipse Che adds support for collaboration where multiple modellers can contribute to building the textual models in an online collaborative manner. This initiative aims to replace the jUCMNAV tool, which is the most comprehensive URN modelling tool to date but only supports a single user.},
  eventtitle = {2019 {{IEEE}}/{{ACM}} 11th {{International Workshop}} on {{Modelling}} in {{Software Engineering}} ({{MiSE}})},
  keywords = {Buildings,Collaboration,Computational modeling,Protocols,Servers,Tools,User Requirements Notation URN jUCMNav Eclipse Che Theia Sprotty LSP ELK TURN TGRL,Visualization},
  file = {/Users/nik/Zotero/storage/C4YLYBBG/8877072.html}
}

@inproceedings{sun:2012:JVMPortableSandboxingJavas,
  title = {{{JVM-Portable Sandboxing}} of {{Java}}’s {{Native Libraries}}},
  booktitle = {Computer {{Security}} – {{ESORICS}} 2012},
  author = {Sun, Mengtao and Tan, Gang},
  editor = {Foresti, Sara and Yung, Moti and Martinelli, Fabio},
  date = {2012},
  pages = {842--858},
  publisher = {Springer},
  doi = {10.1007/978-3-642-33167-1_48},
  abstract = {Although Java provides strong support for safety and security, native libraries used in a Java application can open security holes. Previous work, Robusta, puts native libraries in a sandbox to protect the integrity and security of Java. However, Robusta’s implementation modifies the internals of OpenJDK, a particular implementation of a Java Virtual Machine (JVM). As such, it is not portable to other JVM implementations. This paper shows how to make the idea of sandboxing native libraries JVM-portable. We present a two-layer approach for sandboxing without modifying the internals of a JVM. We also discuss our experience of sandboxing Java’s core native libraries. Experiments show that our approach of JVM-portable sandboxing incurs modest performance overhead on SPECjvm 2008 benchmark programs.},
  isbn = {978-3-642-33167-1},
  langid = {english},
  keywords = {Java Application,Java Code,Java Virtual Machine,Native Code,Performance Overhead},
  file = {/Users/nik/Zotero/storage/5S6XBIUL/Sun and Tan - 2012 - JVM-Portable Sandboxing of Java’s Native Libraries.pdf}
}

@inproceedings{valez:2020:StudentAdoptionPerceptions,
  title = {Student {{Adoption}} and {{Perceptions}} of a {{Web Integrated Development Environment}}: {{An Experience Report}}},
  shorttitle = {Student {{Adoption}} and {{Perceptions}} of a {{Web Integrated Development Environment}}},
  booktitle = {Proceedings of the 51st {{ACM Technical Symposium}} on {{Computer Science Education}}},
  author = {Valez, Martin and Yen, Michael and Le, Mathew and Su, Zhendong and Alipour, Mohammad Amin},
  date = {2020-02-26},
  series = {{{SIGCSE}} '20},
  pages = {1172--1178},
  publisher = {Association for Computing Machinery},
  doi = {10.1145/3328778.3366949},
  url = {https://dl.acm.org/doi/10.1145/3328778.3366949},
  urldate = {2025-09-02},
  abstract = {Students often spend a considerable amount of time and effort installing and configuring programming tools and environments. This can frustrate, and distract them from more important learning objectives, particularly in introductory programming courses. A web-based integrated development environment can serve as a low-threshold, ready-to-use programming environment, and reduce the time and effort needed to start practicing programming.In this paper, we report our experience of developing and deploying a web-based integrated development environment (web IDE) as an optional tool at a large public university that has been in use for over several years in various programming courses.We conducted a survey to understand students' perceptions toward the web IDE and usage of its features. Using the data from the survey, we explored potential correlations between student demographic and behavioral traits in adoption of the web IDE. The results of the survey suggest that around half of the students use the IDE often or very often. We also discovered that the likelihood of adoption of the IDE decreases as students to move to upper classes. In this paper, we also describe broader lessons for educators and researchers.},
  isbn = {978-1-4503-6793-6},
  file = {/Users/nik/Zotero/storage/N6U48CNG/Valez et al. - 2020 - Student Adoption and Perceptions of a Web Integrated Development Environment An Experience Report.pdf}
}
